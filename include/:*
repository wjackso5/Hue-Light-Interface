/*
 * Implementation File (.cpp) for the Bridge Class
 *
 * NOT FINISHED
 */

#include "Bridge_Manager.h"

//CONSTRUCTOR
Bridge_Manager::Bridge_Manager() {
	bridgeList = {}; //Initialize the Bridge List. 
}

//PRIVATE METHODS
/* findBridge method
 *
 * Input: string bridgeName 
 * Output: Bridge if the Bridge is in the list return the
 * "The Bridge we are looking for", returns NULL otherwise 
 */
Bridge Bridge_Manager::findBridge(std::string bridgeName) {
	/* I think we can do without this line, as
	 * list.end() returns an iterator of the elements
	 * beginning after the last element (i.e. an Empty
	 * List) So the condition of the while loop should
	 * prevent us from trying to access an element of
	 * an empty list.

	if (bridgeList.empty() == true) return NULL;

	*/

	std::list<Bridge>::iterator it; //Create an iterator over
	it = bridgeList.begin();        //The bridgeList

	while (it!=bridgeList.end()) { //Loop over the elements in the list
				       //If we find the Bridge, return it.
		/*
		 * Waiting on getName() method to 
		 * be implemented in the Bridge Class.
		 *
		if ((*it).getName() == bridgeName) return *it; 
		*/

	}
	return NULL; //If we reach this line the Bridge is not a member of the 
		     //list so we return NULL.
}

//PUBLIC METHODS
//Note: addBridge is overloaded.

/* addBridge method (without username)
 *
 * Input: name, location, IP address or Hostname, port number of the new  Bridge
 * and the username of the person adding the Bridge.
 * Output: Return true if we are succesful in adding the bridge, false otherwise
 */ 
bool Bridge_Manager::addBridge(std::string name, std::string location, std::string ipAddressOrHostname, int portNumber, std::string userName) {
	Bridge  *newBridge; //Initialize the Bridge
	
	//Try creating the Bridge and adding it to the bridgeList. 
	if ((newBridge = Bridge(name, location, ipAddressOrHostname, portNumber, username)) && (bridgeList.push_front(*newBridge)) return true;

	/* Note that We add the new Bridge to the front of the list because it's
	 * likely we may do something else with this Bridge shortly after addin
	 * g it.
	 */

	/* If we reach the else statement, there was a problem adding the Bridge
	 * (Either it could not be created or it could not be added to the
	 * bridgeList). 
	 */
	else return false; 

}

/* addBridge method (without username)
 *
 * Input: name, location, IP address or Hostname, port number of the Bridge
 * Output: Return true if we are succesful in adding the bridge, false otherwise
 * 
 * For commments see addBridge with username
 */ 
bool Bridge_Manager::addBridge(std::string name, std::string location, std::string ipAddressOrHostname, int portNumber) {
	Bridge  *newBridge;
	
	if ((newBridge = Bridge(name, location, ipAddressOrHostname, portNumber)) && (bridgeList.push_front(*newBridge)) return true;
	
	else return false; 

}

bool Bridge_Manager::editBridge(std::string name, std::string location, std::string ipAddressOrHostname, int portNumber, std::string userName) {
	
}
